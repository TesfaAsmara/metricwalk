# AUTOGENERATED! DO NOT EDIT! File to edit: ../01_functions.ipynb.

# %% auto 0
__all__ = ['max_flow', 'min_cost_max_flow', 'levenshtein', 'jaccard_coefficient', 'common_neighbors', 'lhn_index',
           'preferential_attachment', 'hub_promoted', 'hub_depressed', 'salton_index', 'sorenson_index', 'tversky',
           'adamic_adar', 'resource_allocation', 'generate_walks_for_node']

# %% ../01_functions.ipynb 2
import numpy as np
import networkx as nx
import math
import editdistance


def max_flow(G, current_node, destination):
    if current_node != destination:
        ss_weight, _ = nx.maximum_flow(G, current_node, destination)
    else:
        ss_weight = 0
    return ss_weight

def min_cost_max_flow(G, current_node, destination):
    if current_node != destination:
        mincostFlow = nx.max_flow_min_cost(G, current_node, destination)
        ss_weight = nx.cost_of_flow(G, mincostFlow)
    else:
        ss_weight = 0
    return ss_weight 

def levenshtein(G, current_node, destination):
    if current_node != destination:
        curr = list(G.neighbors(current_node))
        dest = list(G.neighbors(destination))
        ss_weight = editdistance.eval(curr, dest)
    else:
        ss_weight = 0
    return ss_weight

def jaccard_coefficient(G, current_node, destination):
    if current_node != destination:
        curr = list(G.neighbors(current_node))
        dest = list(G.neighbors(destination))
        denominator = len(curr)+len(dest)
        if denominator == 0:
            ss_weight = 0
        else:
            numerator = len(set(curr+dest))
            ss_weight = numerator/denominator
    else:
        ss_weight = 0
    return ss_weight 

def common_neighbors(G, current_node, destination):
    if current_node != destination:
        curr = list(G.neighbors(current_node))
        dest = list(G.neighbors(destination))
        ss_weight = len(set(curr+dest))
    else:
        ss_weight = 0
    return ss_weight 

def lhn_index(G, current_node, destination):
    if current_node != destination:
        curr = list(G.neighbors(current_node))
        dest = list(G.neighbors(destination))
        denominator = len(curr)*len(dest)
        if denominator == 0:
            ss_weight = 0
        else:
            numerator = len(set(curr+dest))
            ss_weight = numerator/denominator
    else:
        ss_weight = 0
    return ss_weight 

def preferential_attachment(G, current_node, destination):
    if current_node != destination:
        curr = list(G.neighbors(current_node))
        dest = list(G.neighbors(destination))
        ss_weight = len(curr) * len(dest)
    else:
        ss_weight = 0
    return ss_weight 

def hub_promoted(G, current_node, destination):
    if current_node != destination:
        curr = list(G.neighbors(current_node))
        dest = list(G.neighbors(destination))
        denominator = min(len(curr),len(dest))
        if denominator == 0:
            ss_weight = 0
        else:
            numerator = len(set(curr+dest))
            ss_weight = numerator/denominator
    else:
        ss_weight = 0
    return ss_weight 

def hub_depressed(G, current_node, destination):
    if current_node != destination:
        curr = list(G.neighbors(current_node))
        dest = list(G.neighbors(destination))
        denominator = max(len(curr),len(dest))
        if denominator == 0:
            ss_weight = 0
        else:
            numerator = len(set(curr+dest))
            ss_weight = numerator/denominator
    else:
        ss_weight = 0
    return ss_weight 

def salton_index(G, current_node, destination):
    if current_node != destination:
        curr = list(G.neighbors(current_node))
        dest = list(G.neighbors(destination))
        denominator = math.sqrt(len(curr)*len(dest))
        if denominator == 0:
            ss_weight = 0
        else:
            numerator = len(set(curr+dest))
            ss_weight = numerator/denominator
    else:
        ss_weight = 0
    return ss_weight 

def sorenson_index(G, current_node, destination):
    if current_node != destination:
        curr = list(G.neighbors(current_node))
        dest = list(G.neighbors(destination))
        denominator = len(curr)+len(dest)
        if denominator == 0:
            ss_weight = 0
        else:
            numerator = 2*len(set(curr+dest))
            ss_weight = numerator/denominator
    else:
        ss_weight = 0
    return ss_weight 

def tversky(G, current_node, destination):
    if current_node != destination:
        curr = list(G.neighbors(current_node))
        dest = list(G.neighbors(destination))
        a = set(curr)
        b = set(dest)
        union = a.union(b)
        a_compl = a.difference(b)
        b_compl = b.difference(a)
        denominator = len(union) + len(curr)*len(a_compl)+len(dest)*len(b_compl)
        if denominator == 0:
            ss_weight = 0
        else:
            numerator = len(a.intersection(b))
            ss_weight = numerator/denominator
    else:
        ss_weight = 0
    return ss_weight

def adamic_adar(G, current_node, destination):
    def calc_weight(node):
        denominator = math.log10(len(list(G.neighbors(node))))
        if denominator == 0:
            return 0
        else:
            return 1 / denominator
        
    if current_node != destination:
        curr = list(G.neighbors(current_node))
        dest = list(G.neighbors(destination))
        intersection = set(curr+dest)
        adamic_adar_indices = sum([calc_weight(node) for node in intersection])
        ss_weight = adamic_adar_indices
    else:
        ss_weight = 0
    return ss_weight

def resource_allocation(G, current_node, destination, num_jobs=-1):
    def calc_weight(node):
        denominator = len(list(G.neighbors(node)))
        if denominator == 0:
            return 0
        else:
            return 1 / denominator
        
    if current_node != destination:
        curr = list(G.neighbors(current_node))
        dest = list(G.neighbors(destination))
        intersection = set(curr+dest)
        resource_allocation_indices = sum([calc_weight(node) for node in intersection])
        ss_weight = resource_allocation_indices
    else:
        ss_weight = 0
    return ss_weight

def generate_walks_for_node(node, num_walks, walk_length, probs):
    node_walks = []
    for walk in range(num_walks):
        walk_list = [node]
        for step in range(walk_length - 1):
            neighbors = list(probs[walk_list[-1]].keys())
            probabilities = list(probs[walk_list[-1]].values())
            next_node = np.random.choice(neighbors, p=probabilities)
            walk_list.append(next_node)
        node_walks.append(walk_list)
    return node_walks
