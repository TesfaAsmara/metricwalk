
<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

## Installation

Currently, MetricWalk can only be installed from source.

### Prerequisites

You will need

- Python3
- Networkx
- Numpy
- Gensim
- Joblib

I highly recommend installing an
[Anaconda](https://www.anaconda.com/distribution/#download-section)
environment. Future versions of MetricWalk will be available on PyPI and
conda.

## Notation

Let us establish some notation used in sections below:

- Vertex set is $V=\{1,2,...,x,y,...,N\}$ where $x$ and $y$ are some
  generic vertices of interest
- Edge set is $E=\{(x,y):x,y \in V\}$
- Graph $G$ is defined by a pair $(V,E)$
- An adjacency matrix of $G$ is a matrix $A=[a_{xy}]_{N\times N}$ such
  that $a_{xy}=1$ if $(x,y) \in E$ otherwise $a_{xy}=0$.
- A set of neighbors of vertex $x$ in graph $G$ is $N(x)$, namely
  $N(x)=\{y:(x,y) \in E\}$. Let $\lvert N(x)\rvert$ denote the number of
  elements in the set of neighbors $N(x)$.

Then I am suggesting the generating the transition probability matrix by
normalizing a matrix where you compute a metric
$m: V \times V \to \mathbb{R}$ across all pairs of nodes. You can then
perform [DeepWalk](https://arxiv.org/abs/1403.6652) on the transformed
graph. These initial measures are mainly local methods, but global and
quasi-local methods can also be utilized.

1.  Common Neighbors $$a_{xy} = \lvert N(x) \cap N(y) \rvert$$

This index measures the number of common neighbors between vertices $x$
and $y$. The higher the number of common neighbors, the more likely the
random walker is to move from vertex $x$ to vertex $y$, as they share a
strong connection through their common neighbors.

2.  Salton Index
    $$a_{xy} = \frac{\lvert N(x) \cap N(y) \rvert}{\sqrt{\lvert N(x) \rvert \times \lvert N(y) \rvert}}$$

This index measures the cosine similarity between the sets of neighbors
of vertices $x$ and $y$. The higher the cosine similarity, the more
likely the random walker is to move from vertex $x$ to vertex $y$, as
they share a similar set of neighbors.

3.  Jaccard Index
    $$a_{xy} = \frac{\lvert N(x) \cap N(y) \rvert}{\lvert N(x) \cup N(y) \rvert}$$

This index measures the proportion of common neighbors between vertices
$x$ and $y$ relative to the total number of neighbors they have. The
higher the proportion of common neighbors, the more likely the random
walker is to move from vertex $x$ to vertex $y$, as they share a strong
connection through their common neighbors relative to their total
neighbors.

4.  Sorenson Index
    $$a_{xy} = \frac{2 \lvert N(x) \cap N(y) \rvert}{\lvert N(x) \rvert + \lvert N(y) \rvert}$$

This index is similar to the Jaccard index, but it takes into account
the size of the individual sets of neighbors. The higher the
intersection between the sets of neighbors of vertices $x$ and $y$
relative to their total number of neighbors, the more likely the random
walker is to move from vertex $x$ to vertex $y$.

5.  Hub Promoted Index
    $$a_{xy} = \frac{2 \lvert N(x) \cap N(y) \rvert}{\min \{\lvert N(x) \rvert, \lvert N(y) \rvert\}}$$

This index measures the strength of the connection between vertices $x$
and $y$ relative to the size of their respective sets of neighbors. The
higher the intersection between the sets of neighbors of vertices $x$
and $y$ relative to the size of the smaller set, the more likely the
random walker is to move from vertex $x$ to vertex $y$, as they have a
strong connection relative to the size of their sets of neighbors.

6.  Hub Depressed Index
    $$a_{xy} = \frac{2 \lvert N(x) \cap N(y) \rvert}{\max \{\lvert N(x) \rvert, \lvert N(y) \rvert\}}$$

This index is the opposite of the Hub Promoted Index. The higher the
intersection between the sets of neighbors of vertices $x$ and $y$
relative to the size of the larger set, the less likely the random
walker is to move from vertex $x$ to vertex $y$, as they have a weak
connection relative to the size of their sets of neighbors.

7.  Leicht-Holme-Newman Index
    $$a_{xy} = \frac{\lvert N(x) \cap N(y) \rvert}{\lvert N(x) \rvert \times \lvert N(y) \rvert}$$

This index measures the probability of finding a common neighbor between
vertices $x$ and $y$ relative to the product of their degrees. The
higher the probability, the more likely the random walker is to move
from vertex $x$ to vertex $y$, as they have a strong connection relative
to their degrees.

8.  Preferential Attachment
    $$a_{xy} = \lvert N(x) \rvert \times \lvert N(y) \rvert$$

This index measures the product of the degrees of vertices $x$ and $y$.
The higher the product, the more likely the random walker is to move
from vertex $x$ to vertex $y$, as they have a high degree.

9.  Adamic–Adar Index
    $$a_{xy} = \sum_{z \in N(x) \cap N(y)} \frac{1}{\log \lvert N(z) \rvert}$$

This index assigns higher weights to common neighbors with lower
degrees, as they are considered more important in measuring the
similarity between vertices $x$ and $y$. The higher the score, the more
likely the random walker is to move from vertex $x$ to vertex $y$, as
they have a strong connection through their common neighbors with lower
degrees.

10. Resource Allocation Index
    $$a_{xy} = \sum_{z \in N(x) \cap N(y)} \frac{1}{\lvert N(z) \rvert}$$

This index measures the amount of resources that would be transmitted
between vertices $x$ and $y$ through their common neighbors. The higher
the score, the more likely the random walker is to move from vertex $x$
to vertex $y$, as they have a strong connection through their common
neighbors.

11. Maximum Flow $$a_{xy} = \texttt{maxFlow}(x,y)$$

The maximum flow between two vertices $x$ and $y$ is the maximum amount
of flow that can be sent from $x$ to $y$ through the edges of the graph,
subject to certain capacity constraints on the edges. The maximum flow
is a measure of the maximum amount of information or resources that can
be transferred from $x$ to $y$. The higher the maximum flow the more
likely the random walker is to move towards edges that can transmit more
information or resources between the two vertices.

12. Maximum-Flow Minimum-Cost $$a_{xy} = \texttt{maxFlowMinCost}(x,y)$$

This measure considers the cost of sending flow through the edges, in
addition to the capacity constraints. The minimum-cost maximum flow
between two vertices $x$ and $y$ is the maximum flow that can be sent
from $x$ to $y$ subject to capacity constraints, where the cost of
sending flow through the edges is minimized. The cost of sending flow
through an edge can be thought of as a measure of the “distance” or
“effort” required to transfer information or resources through that
edge.

Given a
[`MetricWalk`](https://TesfaAsmara.github.io/metricwalk/core.html#metricwalk)
object, these functions can be passed into `MetricWalk.fit()` as
`MetricWalk.<func>` where `<func>` is one of `jaccard_coefficient`,
`adamic_adar`, `resource_allocation`, `common_neighbors`,
`sorenson_index`, `salton_index`, `hub_depressed`, `hub_promoted`,
`preferential_attachment`, `lhn_index`, `max_flow`, and
`max_flow_min_cost`.

## Caveats

- Node names in the input graph must be all strings, or all ints
- Parallel execution not working on Windows (joblib known issue). To run
  non-parallel on Windows pass `workers=1` in the MetricWalk’s
  constructor.
- Note that `max_flow` and `max_flow_min_cost` have a runtime of
  $O(n^4 \sqrt{m})$; parallelization has been incorporated where
  applicable throughout to alleviate the expense of this methodology.
- Moreover, in order to use the `max_flow` and `max_flow_min_cost`
  transformations, you must specify a `capacity` attribute on the edges
  of your Networkx graph. You can do this by setting the capacity of the
  edges equal to the weights of the edges or some other value like so:

``` python
import networkx as nx

# Create a graph
graph = nx.fast_gnp_random_graph(n=100, p=0.5)

# Set the capacity of the edges equal to 1
for u, v in graph.edges:
    # or consider setting this value equal to graph[u][v]['weight'], if it exists for your graph.
    graph[u][v]['capacity'] = 1
```

## Parameters

- `MetricWalk` constructor:
  - `graph`: The first positional argument has to be a networkx graph.
    Node names must be all integers or all strings. On the output model
    they will always be strings.
  - `dimensions`: Embedding dimensions (default: 128)
  - `walk_length`: Number of nodes in each walk (default: 80)
  - `num_walks`: Number of walks per node (default: 10)
  - `workers`: Number of workers for parallel execution (default: 1)
- `MetricWalk.fit` method: Returns a trained `gensim.Word2Vec` model

## How to use

``` python
import networkx as nx
from metricwalk.core import MetricWalk
  

# Create a graph
graph = nx.fast_gnp_random_graph(n=100, p=0.5)

# Precompute probabilities and generate walks - **ON WINDOWS ONLY WORKS WITH workers=1**
metricWalk = MetricWalk(graph, dimensions = 128, window = 10, walk_length = 80, num_walks = 10, workers = 1)

# Embed nodes using preferential attachment
model = metricWalk.fit(metricWalk.preferential_attachment)

# Look for most similar nodes
model.wv.most_similar(2) # Output node names are always strings

# Save embeddings for later use
# model.wv.save_word2vec_format(EMBEDDING_FILENAME)

# Save model for later use
# model.save(EMBEDDING_MODEL_FILENAME)
```

    2
